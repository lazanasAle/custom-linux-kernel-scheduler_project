diff -ruN linux-6.14.8/arch/x86/entry/syscalls/syscall_64.tbl linux-6.14.8-mod/arch/x86/entry/syscalls/syscall_64.tbl
--- linux-6.14.8/arch/x86/entry/syscalls/syscall_64.tbl	2025-05-22 15:31:58.000000000 +0300
+++ linux-6.14.8-mod/arch/x86/entry/syscalls/syscall_64.tbl	2025-05-25 10:17:13.427957553 +0300
@@ -390,6 +390,9 @@
 464	common	getxattrat		sys_getxattrat
 465	common	listxattrat		sys_listxattrat
 466	common	removexattrat		sys_removexattrat
+467 common  set_scheduling_params       sys_set_scheduling_params
+468 common  get_scheduling_params       sys_get_scheduling_params
+469 common  get_scheduling_score        sys_get_scheduling_score
 
 #
 # Due to a historical design error, certain syscalls are numbered differently
diff -ruN linux-6.14.8/include/linux/sched.h linux-6.14.8-mod/include/linux/sched.h
--- linux-6.14.8/include/linux/sched.h	2025-05-22 15:31:58.000000000 +0300
+++ linux-6.14.8-mod/include/linux/sched.h	2025-05-25 09:36:15.906481460 +0300
@@ -1625,6 +1625,9 @@
 #ifdef CONFIG_USER_EVENTS
 	struct user_event_mm		*user_event_mm;
 #endif
+	long				 deadline_1;
+	long				 deadline_2;
+	long				 computation_time;
 
 	/*
 	 * New fields for task_struct should be added above here, so that
diff -ruN linux-6.14.8/include/linux/syscalls.h linux-6.14.8-mod/include/linux/syscalls.h
--- linux-6.14.8/include/linux/syscalls.h	2025-05-22 15:31:58.000000000 +0300
+++ linux-6.14.8-mod/include/linux/syscalls.h	2025-05-25 10:14:42.302126642 +0300
@@ -92,6 +92,7 @@
 #include <linux/key.h>
 #include <linux/personality.h>
 #include <trace/syscall.h>
+#include <linux/my_sched_sys.h>
 
 #ifdef CONFIG_ARCH_HAS_SYSCALL_WRAPPER
 /*
@@ -1316,4 +1317,8 @@
 		int __user *optlen);
 int __sys_setsockopt(int fd, int level, int optname, char __user *optval,
 		int optlen);
+asmlinkage long sys_set_scheduling_params(long deadline_1, long deadline_2, long computation_time);
+asmlinkage long sys_get_scheduling_params(struct d_params *params);
+asmlinkage long sys_get_scheduling_score(void);
+
 #endif
diff -ruN linux-6.14.8/include/uapi/linux/my_sched_sys.h linux-6.14.8-mod/include/uapi/linux/my_sched_sys.h
--- linux-6.14.8/include/uapi/linux/my_sched_sys.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-6.14.8-mod/include/uapi/linux/my_sched_sys.h	2025-05-25 09:33:10.903991680 +0300
@@ -0,0 +1,11 @@
+#ifndef MY_SCHED_SYS_H
+#define MY_SCHED_SYS_H
+#pragma once
+
+struct d_params {
+	long deadline_1;
+	long deadline_2;
+	long computation_time;
+};
+
+#endif /*MY_SCHED_SYS_H*/
diff -ruN linux-6.14.8/Kbuild linux-6.14.8-mod/Kbuild
--- linux-6.14.8/Kbuild	2025-05-22 15:31:58.000000000 +0300
+++ linux-6.14.8-mod/Kbuild	2025-05-25 10:18:08.685495579 +0300
@@ -97,3 +97,4 @@
 obj-$(CONFIG_NET)	+= net/
 obj-y			+= virt/
 obj-y			+= $(ARCH_DRIVERS)
+obj-y			+= my_sched_syscalls/
diff -ruN linux-6.14.8/my_sched_syscalls/Makefile linux-6.14.8-mod/my_sched_syscalls/Makefile
--- linux-6.14.8/my_sched_syscalls/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ linux-6.14.8-mod/my_sched_syscalls/Makefile	2025-05-25 09:38:02.711222637 +0300
@@ -0,0 +1 @@
+obj-y := sched_sys.o
diff -ruN linux-6.14.8/my_sched_syscalls/sched_sys.c linux-6.14.8-mod/my_sched_syscalls/sched_sys.c
--- linux-6.14.8/my_sched_syscalls/sched_sys.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-6.14.8-mod/my_sched_syscalls/sched_sys.c	2025-05-25 10:10:15.353818085 +0300
@@ -0,0 +1,64 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/my_sched_sys.h>
+#include <asm/current.h>
+#include <asm-generic/errno.h>
+#include <linux/syscalls.h>
+#include <linux/uaccess.h>
+#include <linux/types.h>
+#include <linux/timekeeping.h>
+
+
+#define M 1000
+#define H 100
+
+SYSCALL_DEFINE3(set_scheduling_params, long, deadline_1, long, deadline_2, long, computation_time){
+	bool condition_1 = (deadline_1>0 && deadline_2>0) && deadline_1<deadline_2;
+	struct timespec64 now;
+	ktime_get_real_ts64(&now);
+
+	bool condition_2 = (now.tv_sec*M+computation_time)<deadline_2*M;
+
+	if(condition_1 && condition_2){
+		current->deadline_1=deadline_1;
+		current->deadline_2=deadline_2;
+		current->computation_time=computation_time;
+
+		return 0;
+	}
+	return -EINVAL;
+}
+
+
+SYSCALL_DEFINE1(get_scheduling_params, struct d_params *, params){
+	bool condition = (params!=NULL) && access_ok(params, sizeof(struct d_params));
+	if(condition){
+		if(copy_to_user(&params->deadline_1, &current->deadline_1, sizeof(long))!=0){
+			return -EFAULT;
+		}
+		if(copy_to_user(&params->deadline_2, &current->deadline_2, sizeof(long))!=0){
+			return -EFAULT;
+		}
+		if(copy_to_user(&params->computation_time, &current->computation_time, sizeof(long))!=0){
+			return -EFAULT;
+		}
+		return 0;
+	}
+	return -EINVAL;
+}
+
+
+SYSCALL_DEFINE0(get_scheduling_score){
+	struct timespec64 now;
+	ktime_get_real(&now);
+	long D1 = current->deadline_1;
+	long D2 = current->deadline_2;
+	long D3 = now.tv_sec;
+
+	if(D3<D1)
+		return H;
+	else if(D2<D3)
+		return 0;
+	else
+		return ((D2-D3)*100)/(D2-D1);
+}
