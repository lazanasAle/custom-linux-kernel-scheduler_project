diff --git a/kernel/sched/hvf.c b/kernel/sched/hvf.c
index 110c3bca6..667b9f0ba 100644
--- a/kernel/sched/hvf.c
+++ b/kernel/sched/hvf.c
@@ -1,6 +1,7 @@
 #include <linux/sched.h>
 #include <linux/rbtree.h>
 #include <linux/cpumask.h>
+#include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/timekeeping.h>
 #include <asm-generic/errno.h>
@@ -17,7 +18,8 @@ bool hvf_rq_rbtree_insert(struct rb_root *root, struct sched_hvf_entity *se);
 
 const struct sched_class hvf_sched_class;
 
-inline void atomic_insert(struct rq *rq, struct sched_hvf_entity *se){
+static inline
+void enqueue_entity(struct rq *rq, struct sched_hvf_entity *se){
 	struct rq_flags flags;
 	rq_lock(rq, &flags);
 	hvf_rq_rbtree_insert(&rq->hvf.hvf_task_queue, se);
@@ -27,7 +29,14 @@ inline void atomic_insert(struct rq *rq, struct sched_hvf_entity *se){
 
 static void
 enqueue_task_hvf(struct rq *rq, struct task_struct *p, int flags){
-
+	struct hvf_rq *hvf_rq = &rq->hvf;
+	struct sched_hvf_entity *se_hvf = &p->hvf;
+	if(flags & (ENQUEUE_WAKEUP | ENQUEUE_INITIAL | ENQUEUE_MIGRATED | ENQUEUE_RESTORE)){
+		long sval = compute_sched_value(p);
+		pr_info("enqueuing entity with value: %ld\n", sval);
+	}
+	if(se_hvf != hvf_rq->curr)
+		enqueue_entity(rq, se_hvf);
 }
 
 
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index ffa5786fe..75a174115 100644
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -659,6 +659,7 @@ struct balance_callback {
 struct hvf_rq {
 	struct rb_root	hvf_task_queue;
 	struct sched_hvf_entity *max_value_entity;
+	struct sched_hvf_entity *curr;
 };
 
 
